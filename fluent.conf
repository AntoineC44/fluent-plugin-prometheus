<source>
  @type tcp
  format json
  bind 0.0.0.0
  port 5170
  tag test
</source>
<match test>
  @type prometheus
  <metric>
    name histogram
    type histogram
    desc histogram with current implem, not initialized until first event
    key test
    <labels>
      label a
    </labels>
  </metric>
  <metric>
    name histogram_initialized
    type histogram
    desc histogram initialized
    key test
    buckets 0, 1, 10, 1000
    <labels>
      iam initialized!
    </labels>
    <initlabels>
      iam initialized!
    </initlabels>
  </metric>
  <metric>
    name alert_counter_initalized
    type counter
    desc User knowing part of/all future values of reccordAccessor $.filename can initialize the corresponding counters
    <labels>
      filename "$.filename"
    </labels>
    <initlabels>
      filename "foo.txt"
    </initlabels>
    <initlabels>
      filename "foo.tar.gz"
    </initlabels>
  </metric>
  <metric>
    name simple_summary_initialized
    type summary
    desc Providing no initlabels in the block yields a simple initialized metric
    key test
    <initlabels>
    </initlabels>
  </metric>
</match>

<match>
  @type prometheus
  <metric>
    name counter
    type counter
    desc string labels must be identical between labels and initlabels blocks
    key test
    <labels>
      source fluentd
      filename "$.filename"
    </labels>
    <initlabels>
      source fluentd
      filename "foo.tar.gz"
    </initlabels>
    <initlabels>
      source fluentd
      filename "foo.txt"
    </initlabels>
  </metric>
</match>


<match>
  @type prometheus
  <labels>
    globallabel initvalue2
  </labels>
  <metric>
    name counter_with_global_label
    type counter
    desc Identically, global labels must be initialized in initlabels block
    <labels>
      locallabel $.key
    </labels>
    <initlabels>
      locallabel initvalue
      globallabel initvalue2
    </initlabels>
  </metric>
</match>


<source>
  @type prometheus
</source>
